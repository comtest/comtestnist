/*
* generated by Xtext
*/
package citlab.model.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class CitLGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class CitModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CitModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCitModelAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cModelKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cDefinitionsKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cDefinitionsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cDefinitionsConstantParserRuleCall_3_1_0 = (RuleCall)cDefinitionsAssignment_3_1.eContents().get(0);
		private final Keyword cEndKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cTypesKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cTypesAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cTypesNamedTypeParserRuleCall_4_1_0 = (RuleCall)cTypesAssignment_4_1.eContents().get(0);
		private final Keyword cEndKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		private final Keyword cParametersKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cParametersAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cParametersParameterParserRuleCall_6_0 = (RuleCall)cParametersAssignment_6.eContents().get(0);
		private final Keyword cEndKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cConstraintsKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cConstraintsAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cConstraintsRuleParserRuleCall_8_1_0 = (RuleCall)cConstraintsAssignment_8_1.eContents().get(0);
		private final Keyword cEndKeyword_8_2 = (Keyword)cGroup_8.eContents().get(2);
		private final Group cGroup_9 = (Group)cGroup.eContents().get(9);
		private final Keyword cSeedsKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final Assignment cSeedsAssignment_9_1 = (Assignment)cGroup_9.eContents().get(1);
		private final RuleCall cSeedsSeedParserRuleCall_9_1_0 = (RuleCall)cSeedsAssignment_9_1.eContents().get(0);
		private final Keyword cEndKeyword_9_2 = (Keyword)cGroup_9.eContents().get(2);
		private final Group cGroup_10 = (Group)cGroup.eContents().get(10);
		private final Keyword cTestGoalsKeyword_10_0 = (Keyword)cGroup_10.eContents().get(0);
		private final Assignment cTestGoalsAssignment_10_1 = (Assignment)cGroup_10.eContents().get(1);
		private final RuleCall cTestGoalsRuleParserRuleCall_10_1_0 = (RuleCall)cTestGoalsAssignment_10_1.eContents().get(0);
		private final Keyword cEndKeyword_10_2 = (Keyword)cGroup_10.eContents().get(2);
		
		//CitModel:
		//	{CitModel} "Model" name=ID // definition of constants
		//	("Definitions:" definitions+=Constant+ "end")? //type allow to declear a list of element and reuse them in the enumeratives that share a same domain
		//	("Types:" Types+=NamedType+ "end")? // Parameters - mandatory
		//	"Parameters:" parameters+=Parameter+ "end" // constraints
		//	("Constraints:" constraints+=Rule+ "end")? // seeds 
		//	("Seeds:" seeds+=Seed+ "end")? // test goals
		//	("TestGoals:" testGoals+=Rule+ "end")?;
		public ParserRule getRule() { return rule; }

		//{CitModel} "Model" name=ID // definition of constants
		//("Definitions:" definitions+=Constant+ "end")? //type allow to declear a list of element and reuse them in the enumeratives that share a same domain
		//("Types:" Types+=NamedType+ "end")? // Parameters - mandatory
		//"Parameters:" parameters+=Parameter+ "end" // constraints
		//("Constraints:" constraints+=Rule+ "end")? // seeds 
		//("Seeds:" seeds+=Seed+ "end")? // test goals
		//("TestGoals:" testGoals+=Rule+ "end")?
		public Group getGroup() { return cGroup; }

		//{CitModel}
		public Action getCitModelAction_0() { return cCitModelAction_0; }

		//"Model"
		public Keyword getModelKeyword_1() { return cModelKeyword_1; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//("Definitions:" definitions+=Constant+ "end")?
		public Group getGroup_3() { return cGroup_3; }

		//"Definitions:"
		public Keyword getDefinitionsKeyword_3_0() { return cDefinitionsKeyword_3_0; }

		//definitions+=Constant+
		public Assignment getDefinitionsAssignment_3_1() { return cDefinitionsAssignment_3_1; }

		//Constant
		public RuleCall getDefinitionsConstantParserRuleCall_3_1_0() { return cDefinitionsConstantParserRuleCall_3_1_0; }

		//"end"
		public Keyword getEndKeyword_3_2() { return cEndKeyword_3_2; }

		//("Types:" Types+=NamedType+ "end")?
		public Group getGroup_4() { return cGroup_4; }

		//"Types:"
		public Keyword getTypesKeyword_4_0() { return cTypesKeyword_4_0; }

		//Types+=NamedType+
		public Assignment getTypesAssignment_4_1() { return cTypesAssignment_4_1; }

		//NamedType
		public RuleCall getTypesNamedTypeParserRuleCall_4_1_0() { return cTypesNamedTypeParserRuleCall_4_1_0; }

		//"end"
		public Keyword getEndKeyword_4_2() { return cEndKeyword_4_2; }

		//// Parameters - mandatory
		//"Parameters:"
		public Keyword getParametersKeyword_5() { return cParametersKeyword_5; }

		//parameters+=Parameter+
		public Assignment getParametersAssignment_6() { return cParametersAssignment_6; }

		//Parameter
		public RuleCall getParametersParameterParserRuleCall_6_0() { return cParametersParameterParserRuleCall_6_0; }

		//"end"
		public Keyword getEndKeyword_7() { return cEndKeyword_7; }

		//("Constraints:" constraints+=Rule+ "end")?
		public Group getGroup_8() { return cGroup_8; }

		//"Constraints:"
		public Keyword getConstraintsKeyword_8_0() { return cConstraintsKeyword_8_0; }

		//constraints+=Rule+
		public Assignment getConstraintsAssignment_8_1() { return cConstraintsAssignment_8_1; }

		//Rule
		public RuleCall getConstraintsRuleParserRuleCall_8_1_0() { return cConstraintsRuleParserRuleCall_8_1_0; }

		//"end"
		public Keyword getEndKeyword_8_2() { return cEndKeyword_8_2; }

		//("Seeds:" seeds+=Seed+ "end")?
		public Group getGroup_9() { return cGroup_9; }

		//"Seeds:"
		public Keyword getSeedsKeyword_9_0() { return cSeedsKeyword_9_0; }

		//seeds+=Seed+
		public Assignment getSeedsAssignment_9_1() { return cSeedsAssignment_9_1; }

		//Seed
		public RuleCall getSeedsSeedParserRuleCall_9_1_0() { return cSeedsSeedParserRuleCall_9_1_0; }

		//"end"
		public Keyword getEndKeyword_9_2() { return cEndKeyword_9_2; }

		//("TestGoals:" testGoals+=Rule+ "end")?
		public Group getGroup_10() { return cGroup_10; }

		//"TestGoals:"
		public Keyword getTestGoalsKeyword_10_0() { return cTestGoalsKeyword_10_0; }

		//testGoals+=Rule+
		public Assignment getTestGoalsAssignment_10_1() { return cTestGoalsAssignment_10_1; }

		//Rule
		public RuleCall getTestGoalsRuleParserRuleCall_10_1_0() { return cTestGoalsRuleParserRuleCall_10_1_0; }

		//"end"
		public Keyword getEndKeyword_10_2() { return cEndKeyword_10_2; }
	}

	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Constant");
		private final RuleCall cConstantNumberParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// for now only numerical constants
		//Constant:
		//	ConstantNumber;
		public ParserRule getRule() { return rule; }

		//ConstantNumber
		public RuleCall getConstantNumberParserRuleCall() { return cConstantNumberParserRuleCall; }
	}

	public class ConstantNumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstantNumber");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNumberKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueINTTerminalRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ConstantNumber:
		//	"Number" name=ID "=" value=INT ";";
		public ParserRule getRule() { return rule; }

		//"Number" name=ID "=" value=INT ";"
		public Group getGroup() { return cGroup; }

		//"Number"
		public Keyword getNumberKeyword_0() { return cNumberKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//value=INT
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_3_0() { return cValueINTTerminalRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Parameter");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEnumerativeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBooleanParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cNumericalParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Parameter:
		//	Enumerative | Boolean | Numerical;
		public ParserRule getRule() { return rule; }

		//Enumerative | Boolean | Numerical
		public Alternatives getAlternatives() { return cAlternatives; }

		//Enumerative
		public RuleCall getEnumerativeParserRuleCall_0() { return cEnumerativeParserRuleCall_0; }

		//Boolean
		public RuleCall getBooleanParserRuleCall_1() { return cBooleanParserRuleCall_1; }

		//Numerical
		public RuleCall getNumericalParserRuleCall_2() { return cNumericalParserRuleCall_2; }
	}

	public class ParametersExElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParametersEx");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cParameterParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNumericalExParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// parameter U Numerical
		//ParametersEx:
		//	Parameter | NumericalEx;
		public ParserRule getRule() { return rule; }

		//Parameter | NumericalEx
		public Alternatives getAlternatives() { return cAlternatives; }

		//Parameter
		public RuleCall getParameterParserRuleCall_0() { return cParameterParserRuleCall_0; }

		//NumericalEx
		public RuleCall getNumericalExParserRuleCall_1() { return cNumericalExParserRuleCall_1; }
	}

	public class NumericalExElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumericalEx");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumericalParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cConstantNumberParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//NumericalEx:
		//	Numerical | ConstantNumber;
		public ParserRule getRule() { return rule; }

		//Numerical | ConstantNumber
		public Alternatives getAlternatives() { return cAlternatives; }

		//Numerical
		public RuleCall getNumericalParserRuleCall_0() { return cNumericalParserRuleCall_0; }

		//ConstantNumber
		public RuleCall getConstantNumberParserRuleCall_1() { return cConstantNumberParserRuleCall_1; }
	}

	public class NumericalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Numerical");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumbersParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRangeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// numerical parameter
		//Numerical:
		//	Numbers | Range;
		public ParserRule getRule() { return rule; }

		//Numbers | Range
		public Alternatives getAlternatives() { return cAlternatives; }

		//Numbers
		public RuleCall getNumbersParserRuleCall_0() { return cNumbersParserRuleCall_0; }

		//Range
		public RuleCall getRangeParserRuleCall_1() { return cRangeParserRuleCall_1; }
	}

	public class EnumerativeTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumerativeType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNamedTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAnonymousTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//EnumerativeType:
		//	NamedType | AnonymousType;
		public ParserRule getRule() { return rule; }

		//NamedType | AnonymousType
		public Alternatives getAlternatives() { return cAlternatives; }

		//NamedType
		public RuleCall getNamedTypeParserRuleCall_0() { return cNamedTypeParserRuleCall_0; }

		//AnonymousType
		public RuleCall getAnonymousTypeParserRuleCall_1() { return cAnonymousTypeParserRuleCall_1; }
	}

	public class NamedTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NamedType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumerativeTypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cElementsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cElementsElementParserRuleCall_3_0 = (RuleCall)cElementsAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//NamedType:
		//	"EnumerativeType" name=ID "{" elements+=Element* "}" ";";
		public ParserRule getRule() { return rule; }

		//"EnumerativeType" name=ID "{" elements+=Element* "}" ";"
		public Group getGroup() { return cGroup; }

		//"EnumerativeType"
		public Keyword getEnumerativeTypeKeyword_0() { return cEnumerativeTypeKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//elements+=Element*
		public Assignment getElementsAssignment_3() { return cElementsAssignment_3; }

		//Element
		public RuleCall getElementsElementParserRuleCall_3_0() { return cElementsElementParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class AnonymousTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AnonymousType");
		private final Assignment cElementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cElementsElementParserRuleCall_0 = (RuleCall)cElementsAssignment.eContents().get(0);
		
		////An enumaritive can be a list of element or a reference to a NamedType
		//AnonymousType:
		//	elements+=Element+;
		public ParserRule getRule() { return rule; }

		//elements+=Element+
		public Assignment getElementsAssignment() { return cElementsAssignment; }

		//Element
		public RuleCall getElementsElementParserRuleCall_0() { return cElementsElementParserRuleCall_0; }
	}

	public class EnumerativeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Enumerative");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnumerativeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Keyword cColonKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Assignment cNamedTypeAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final CrossReference cNamedTypeNamedTypeCrossReference_2_0_1_0 = (CrossReference)cNamedTypeAssignment_2_0_1.eContents().get(0);
		private final RuleCall cNamedTypeNamedTypeIDTerminalRuleCall_2_0_1_0_1 = (RuleCall)cNamedTypeNamedTypeCrossReference_2_0_1_0.eContents().get(1);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cAtypeAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cAtypeAnonymousTypeParserRuleCall_2_1_1_0 = (RuleCall)cAtypeAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2_1_2 = (Keyword)cGroup_2_1.eContents().get(2);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// elements in the enumerative
		//Enumerative:
		//	"Enumerative" name=ID (":" namedType=[NamedType] | "{" atype=AnonymousType "}") ";";
		public ParserRule getRule() { return rule; }

		//"Enumerative" name=ID (":" namedType=[NamedType] | "{" atype=AnonymousType "}") ";"
		public Group getGroup() { return cGroup; }

		//"Enumerative"
		public Keyword getEnumerativeKeyword_0() { return cEnumerativeKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//":" namedType=[NamedType] | "{" atype=AnonymousType "}"
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//":" namedType=[NamedType]
		public Group getGroup_2_0() { return cGroup_2_0; }

		//":"
		public Keyword getColonKeyword_2_0_0() { return cColonKeyword_2_0_0; }

		//namedType=[NamedType]
		public Assignment getNamedTypeAssignment_2_0_1() { return cNamedTypeAssignment_2_0_1; }

		//[NamedType]
		public CrossReference getNamedTypeNamedTypeCrossReference_2_0_1_0() { return cNamedTypeNamedTypeCrossReference_2_0_1_0; }

		//ID
		public RuleCall getNamedTypeNamedTypeIDTerminalRuleCall_2_0_1_0_1() { return cNamedTypeNamedTypeIDTerminalRuleCall_2_0_1_0_1; }

		//"{" atype=AnonymousType "}"
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2_1_0() { return cLeftCurlyBracketKeyword_2_1_0; }

		//atype=AnonymousType
		public Assignment getAtypeAssignment_2_1_1() { return cAtypeAssignment_2_1_1; }

		//AnonymousType
		public RuleCall getAtypeAnonymousTypeParserRuleCall_2_1_1_0() { return cAtypeAnonymousTypeParserRuleCall_2_1_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2_1_2() { return cRightCurlyBracketKeyword_2_1_2; }

		//";"
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}

	public class ElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Element");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameElementIDParserRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Element:
		//	name=elementID;
		public ParserRule getRule() { return rule; }

		//name=elementID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//elementID
		public RuleCall getNameElementIDParserRuleCall_0() { return cNameElementIDParserRuleCall_0; }
	}

	public class BooleanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Boolean");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBooleanKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Boolean:
		//	"Boolean" name=ID ";";
		public ParserRule getRule() { return rule; }

		//"Boolean" name=ID ";"
		public Group getGroup() { return cGroup; }

		//"Boolean"
		public Keyword getBooleanKeyword_0() { return cBooleanKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}

	public class NumbersElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Numbers");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNumbersKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValuesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValuesPossiblySignedNumberParserRuleCall_3_0 = (RuleCall)cValuesAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//// list of numbers
		//Numbers:
		//	"Numbers" name=ID "{" values+=PossiblySignedNumber+ "}" ";";
		public ParserRule getRule() { return rule; }

		//"Numbers" name=ID "{" values+=PossiblySignedNumber+ "}" ";"
		public Group getGroup() { return cGroup; }

		//"Numbers"
		public Keyword getNumbersKeyword_0() { return cNumbersKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }

		//values+=PossiblySignedNumber+
		public Assignment getValuesAssignment_3() { return cValuesAssignment_3; }

		//PossiblySignedNumber
		public RuleCall getValuesPossiblySignedNumberParserRuleCall_3_0() { return cValuesPossiblySignedNumberParserRuleCall_3_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }

		//";"
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class RangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Range");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRangeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBeginAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBeginPossiblySignedNumberParserRuleCall_3_0 = (RuleCall)cBeginAssignment_3.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cEndAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cEndPossiblySignedNumberParserRuleCall_5_0 = (RuleCall)cEndAssignment_5.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cStepKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cStepAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cStepINTTerminalRuleCall_7_1_0 = (RuleCall)cStepAssignment_7_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		////range of value of a constant
		//Range:
		//	"Range" name=ID "[" begin=PossiblySignedNumber ".." end=PossiblySignedNumber "]" ("step" step=INT)? ";";
		public ParserRule getRule() { return rule; }

		//"Range" name=ID "[" begin=PossiblySignedNumber ".." end=PossiblySignedNumber "]" ("step" step=INT)? ";"
		public Group getGroup() { return cGroup; }

		//"Range"
		public Keyword getRangeKeyword_0() { return cRangeKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }

		//begin=PossiblySignedNumber
		public Assignment getBeginAssignment_3() { return cBeginAssignment_3; }

		//PossiblySignedNumber
		public RuleCall getBeginPossiblySignedNumberParserRuleCall_3_0() { return cBeginPossiblySignedNumberParserRuleCall_3_0; }

		//".."
		public Keyword getFullStopFullStopKeyword_4() { return cFullStopFullStopKeyword_4; }

		//end=PossiblySignedNumber
		public Assignment getEndAssignment_5() { return cEndAssignment_5; }

		//PossiblySignedNumber
		public RuleCall getEndPossiblySignedNumberParserRuleCall_5_0() { return cEndPossiblySignedNumberParserRuleCall_5_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_6() { return cRightSquareBracketKeyword_6; }

		//("step" step=INT)?
		public Group getGroup_7() { return cGroup_7; }

		//"step"
		public Keyword getStepKeyword_7_0() { return cStepKeyword_7_0; }

		//step=INT
		public Assignment getStepAssignment_7_1() { return cStepAssignment_7_1; }

		//INT
		public RuleCall getStepINTTerminalRuleCall_7_1_0() { return cStepINTTerminalRuleCall_7_1_0; }

		//";"
		public Keyword getSemicolonKeyword_8() { return cSemicolonKeyword_8; }
	}

	public class RuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Rule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNumberSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cOrExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cNumberSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// CONSTRAINTS
		//// expressions defined in top down way starting from less precedence	
		//Rule:
		//	"#" OrExpression "#";
		public ParserRule getRule() { return rule; }

		//"#" OrExpression "#"
		public Group getGroup() { return cGroup; }

		//"#"
		public Keyword getNumberSignKeyword_0() { return cNumberSignKeyword_0; }

		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_1() { return cOrExpressionParserRuleCall_1; }

		//"#"
		public Keyword getNumberSignKeyword_2() { return cNumberSignKeyword_2; }
	}

	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cOrExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOpOrOperatorsEnumRuleCall_1_0_1_0 = (RuleCall)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRightAndExpressionParserRuleCall_1_0_2_0 = (RuleCall)cRightAssignment_1_0_2.eContents().get(0);
		
		//OrExpression returns Expression:
		//	AndExpression => ({OrExpression.left=current} op=OrOperators right=AndExpression)*;
		public ParserRule getRule() { return rule; }

		//AndExpression => ({OrExpression.left=current} op=OrOperators right=AndExpression)*
		public Group getGroup() { return cGroup; }

		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }

		//=> ({OrExpression.left=current} op=OrOperators right=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{OrExpression.left=current} op=OrOperators right=AndExpression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{OrExpression.left=current}
		public Action getOrExpressionLeftAction_1_0_0() { return cOrExpressionLeftAction_1_0_0; }

		//op=OrOperators
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }

		//OrOperators
		public RuleCall getOpOrOperatorsEnumRuleCall_1_0_1_0() { return cOpOrOperatorsEnumRuleCall_1_0_1_0; }

		//right=AndExpression
		public Assignment getRightAssignment_1_0_2() { return cRightAssignment_1_0_2; }

		//AndExpression
		public RuleCall getRightAndExpressionParserRuleCall_1_0_2_0() { return cRightAndExpressionParserRuleCall_1_0_2_0; }
	}

	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cImpliesExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cAndExpressionLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1 = (Assignment)cGroup_1_0.eContents().get(1);
		private final RuleCall cOpAndOperatorsEnumRuleCall_1_0_1_0 = (RuleCall)cOpAssignment_1_0_1.eContents().get(0);
		private final Assignment cRightAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRightImpliesExpressionParserRuleCall_1_0_2_0 = (RuleCall)cRightAssignment_1_0_2.eContents().get(0);
		
		//AndExpression returns Expression:
		//	ImpliesExpression => ({AndExpression.left=current} op=AndOperators right=ImpliesExpression)*;
		public ParserRule getRule() { return rule; }

		//ImpliesExpression => ({AndExpression.left=current} op=AndOperators right=ImpliesExpression)*
		public Group getGroup() { return cGroup; }

		//ImpliesExpression
		public RuleCall getImpliesExpressionParserRuleCall_0() { return cImpliesExpressionParserRuleCall_0; }

		//=> ({AndExpression.left=current} op=AndOperators right=ImpliesExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{AndExpression.left=current} op=AndOperators right=ImpliesExpression
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{AndExpression.left=current}
		public Action getAndExpressionLeftAction_1_0_0() { return cAndExpressionLeftAction_1_0_0; }

		//op=AndOperators
		public Assignment getOpAssignment_1_0_1() { return cOpAssignment_1_0_1; }

		//AndOperators
		public RuleCall getOpAndOperatorsEnumRuleCall_1_0_1_0() { return cOpAndOperatorsEnumRuleCall_1_0_1_0; }

		//right=ImpliesExpression
		public Assignment getRightAssignment_1_0_2() { return cRightAssignment_1_0_2; }

		//ImpliesExpression
		public RuleCall getRightImpliesExpressionParserRuleCall_1_0_2_0() { return cRightImpliesExpressionParserRuleCall_1_0_2_0; }
	}

	public class ImpliesExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ImpliesExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cImpliesExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpImpliesOperatorEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// 
		//ImpliesExpression returns Expression:
		//	Primary ({ImpliesExpression.left=current} op=ImpliesOperator right=Primary)*;
		public ParserRule getRule() { return rule; }

		//Primary ({ImpliesExpression.left=current} op=ImpliesOperator right=Primary)*
		public Group getGroup() { return cGroup; }

		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }

		//({ImpliesExpression.left=current} op=ImpliesOperator right=Primary)*
		public Group getGroup_1() { return cGroup_1; }

		//{ImpliesExpression.left=current}
		public Action getImpliesExpressionLeftAction_1_0() { return cImpliesExpressionLeftAction_1_0; }

		//op=ImpliesOperator
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//ImpliesOperator
		public RuleCall getOpImpliesOperatorEnumRuleCall_1_1_0() { return cOpImpliesOperatorEnumRuleCall_1_1_0; }

		//right=Primary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Primary
		public RuleCall getRightPrimaryParserRuleCall_1_2_0() { return cRightPrimaryParserRuleCall_1_2_0; }
	}

	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNotExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cOrExpressionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final RuleCall cAtomicPredicateParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Primary returns Expression:
		//	NotExpression | "(" OrExpression ")" | AtomicPredicate;
		public ParserRule getRule() { return rule; }

		//NotExpression | "(" OrExpression ")" | AtomicPredicate
		public Alternatives getAlternatives() { return cAlternatives; }

		//NotExpression
		public RuleCall getNotExpressionParserRuleCall_0() { return cNotExpressionParserRuleCall_0; }

		//"(" OrExpression ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_1_1() { return cOrExpressionParserRuleCall_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }

		//AtomicPredicate
		public RuleCall getAtomicPredicateParserRuleCall_2() { return cAtomicPredicateParserRuleCall_2; }
	}

	public class NotExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NotExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cNotKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Action cNotExpressionPredicateAction_2 = (Action)cGroup.eContents().get(2);
		
		//NotExpression returns Expression:
		//	("!" | "not") Primary {NotExpression.predicate=current};
		public ParserRule getRule() { return rule; }

		//("!" | "not") Primary {NotExpression.predicate=current}
		public Group getGroup() { return cGroup; }

		//"!" | "not"
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"!"
		public Keyword getExclamationMarkKeyword_0_0() { return cExclamationMarkKeyword_0_0; }

		//"not"
		public Keyword getNotKeyword_0_1() { return cNotKeyword_0_1; }

		//Primary
		public RuleCall getPrimaryParserRuleCall_1() { return cPrimaryParserRuleCall_1; }

		//{NotExpression.predicate=current}
		public Action getNotExpressionPredicateAction_2() { return cNotExpressionPredicateAction_2; }
	}

	public class AtomicPredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtomicPredicate");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEnumAssignParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBoolAssignParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRelationalExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// return an atomic predicate that cannot be further decomposed in predicates
		//AtomicPredicate:
		//	EnumAssign | BoolAssign | RelationalExpression;
		public ParserRule getRule() { return rule; }

		//EnumAssign | BoolAssign | RelationalExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//EnumAssign
		public RuleCall getEnumAssignParserRuleCall_0() { return cEnumAssignParserRuleCall_0; }

		//BoolAssign
		public RuleCall getBoolAssignParserRuleCall_1() { return cBoolAssignParserRuleCall_1; }

		//RelationalExpression
		public RuleCall getRelationalExpressionParserRuleCall_2() { return cRelationalExpressionParserRuleCall_2; }
	}

	public class BoolAssignElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BoolAssign");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cLeftBooleanCrossReference_0_0 = (CrossReference)cLeftAssignment_0.eContents().get(0);
		private final RuleCall cLeftBooleanIDTerminalRuleCall_0_0_1 = (RuleCall)cLeftBooleanCrossReference_0_0.eContents().get(1);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOpAssignmentOperatorsEnumRuleCall_1_0 = (RuleCall)cOpAssignment_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightBooleanConstEnumRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//BoolAssign:
		//	=> left=[Boolean] op=AssignmentOperators right=BooleanConst;
		public ParserRule getRule() { return rule; }

		//=> left=[Boolean] op=AssignmentOperators right=BooleanConst
		public Group getGroup() { return cGroup; }

		//=> left=[Boolean]
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }

		//[Boolean]
		public CrossReference getLeftBooleanCrossReference_0_0() { return cLeftBooleanCrossReference_0_0; }

		//ID
		public RuleCall getLeftBooleanIDTerminalRuleCall_0_0_1() { return cLeftBooleanIDTerminalRuleCall_0_0_1; }

		//op=AssignmentOperators
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }

		//AssignmentOperators
		public RuleCall getOpAssignmentOperatorsEnumRuleCall_1_0() { return cOpAssignmentOperatorsEnumRuleCall_1_0; }

		//right=BooleanConst
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }

		//BooleanConst
		public RuleCall getRightBooleanConstEnumRuleCall_2_0() { return cRightBooleanConstEnumRuleCall_2_0; }
	}

	public class EnumAssignElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumAssign");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cLeftEnumerativeCrossReference_0_0 = (CrossReference)cLeftAssignment_0.eContents().get(0);
		private final RuleCall cLeftEnumerativeIDTerminalRuleCall_0_0_1 = (RuleCall)cLeftEnumerativeCrossReference_0_0.eContents().get(1);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOpAssignmentOperatorsEnumRuleCall_1_0 = (RuleCall)cOpAssignment_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cRightElementCrossReference_2_0 = (CrossReference)cRightAssignment_2.eContents().get(0);
		private final RuleCall cRightElementFQNParserRuleCall_2_0_1 = (RuleCall)cRightElementCrossReference_2_0.eContents().get(1);
		
		//EnumAssign:
		//	=> left=[Enumerative] op=AssignmentOperators right=[Element|FQN];
		public ParserRule getRule() { return rule; }

		//=> left=[Enumerative] op=AssignmentOperators right=[Element|FQN]
		public Group getGroup() { return cGroup; }

		//=> left=[Enumerative]
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }

		//[Enumerative]
		public CrossReference getLeftEnumerativeCrossReference_0_0() { return cLeftEnumerativeCrossReference_0_0; }

		//ID
		public RuleCall getLeftEnumerativeIDTerminalRuleCall_0_0_1() { return cLeftEnumerativeIDTerminalRuleCall_0_0_1; }

		//op=AssignmentOperators
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }

		//AssignmentOperators
		public RuleCall getOpAssignmentOperatorsEnumRuleCall_1_0() { return cOpAssignmentOperatorsEnumRuleCall_1_0; }

		//right=[Element|FQN]
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }

		//[Element|FQN]
		public CrossReference getRightElementCrossReference_2_0() { return cRightElementCrossReference_2_0; }

		//FQN
		public RuleCall getRightElementFQNParserRuleCall_2_0_1() { return cRightElementFQNParserRuleCall_2_0_1; }
	}

	public class RelationalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RelationalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cLeftAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final CrossReference cLeftNumericalCrossReference_0_0_0 = (CrossReference)cLeftAssignment_0_0.eContents().get(0);
		private final RuleCall cLeftNumericalIDTerminalRuleCall_0_0_0_1 = (RuleCall)cLeftNumericalCrossReference_0_0_0.eContents().get(1);
		private final Assignment cOpAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Alternatives cOpAlternatives_0_1_0 = (Alternatives)cOpAssignment_0_1.eContents().get(0);
		private final RuleCall cOpAssignmentOperatorsEnumRuleCall_0_1_0_0 = (RuleCall)cOpAlternatives_0_1_0.eContents().get(0);
		private final RuleCall cOpRelationalOperatorsEnumRuleCall_0_1_0_1 = (RuleCall)cOpAlternatives_0_1_0.eContents().get(1);
		private final Assignment cRightAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cRightPlusMinusParserRuleCall_0_2_0 = (RuleCall)cRightAssignment_0_2.eContents().get(0);
		
		//// numerical expressions
		//RelationalExpression:
		//	=> (left=[Numerical] op=(AssignmentOperators | RelationalOperators) right=PlusMinus);
		public ParserRule getRule() { return rule; }

		//=> (left=[Numerical] op=(AssignmentOperators | RelationalOperators) right=PlusMinus)
		public Group getGroup() { return cGroup; }

		//left=[Numerical] op=(AssignmentOperators | RelationalOperators) right=PlusMinus
		public Group getGroup_0() { return cGroup_0; }

		//left=[Numerical]
		public Assignment getLeftAssignment_0_0() { return cLeftAssignment_0_0; }

		//[Numerical]
		public CrossReference getLeftNumericalCrossReference_0_0_0() { return cLeftNumericalCrossReference_0_0_0; }

		//ID
		public RuleCall getLeftNumericalIDTerminalRuleCall_0_0_0_1() { return cLeftNumericalIDTerminalRuleCall_0_0_0_1; }

		//op=(AssignmentOperators | RelationalOperators)
		public Assignment getOpAssignment_0_1() { return cOpAssignment_0_1; }

		//AssignmentOperators | RelationalOperators
		public Alternatives getOpAlternatives_0_1_0() { return cOpAlternatives_0_1_0; }

		//AssignmentOperators
		public RuleCall getOpAssignmentOperatorsEnumRuleCall_0_1_0_0() { return cOpAssignmentOperatorsEnumRuleCall_0_1_0_0; }

		//RelationalOperators
		public RuleCall getOpRelationalOperatorsEnumRuleCall_0_1_0_1() { return cOpRelationalOperatorsEnumRuleCall_0_1_0_1; }

		//right=PlusMinus
		public Assignment getRightAssignment_0_2() { return cRightAssignment_0_2; }

		//PlusMinus
		public RuleCall getRightPlusMinusParserRuleCall_0_2_0() { return cRightPlusMinusParserRuleCall_0_2_0; }
	}

	public class PlusMinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PlusMinus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cModMultDivParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPlusMinusLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpPlusMinusOperatorsEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightModMultDivParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//PlusMinus returns Expression:
		//	ModMultDiv ({PlusMinus.left=current} op=PlusMinusOperators right=ModMultDiv)*;
		public ParserRule getRule() { return rule; }

		//ModMultDiv ({PlusMinus.left=current} op=PlusMinusOperators right=ModMultDiv)*
		public Group getGroup() { return cGroup; }

		//ModMultDiv
		public RuleCall getModMultDivParserRuleCall_0() { return cModMultDivParserRuleCall_0; }

		//({PlusMinus.left=current} op=PlusMinusOperators right=ModMultDiv)*
		public Group getGroup_1() { return cGroup_1; }

		//{PlusMinus.left=current}
		public Action getPlusMinusLeftAction_1_0() { return cPlusMinusLeftAction_1_0; }

		//op=PlusMinusOperators
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//PlusMinusOperators
		public RuleCall getOpPlusMinusOperatorsEnumRuleCall_1_1_0() { return cOpPlusMinusOperatorsEnumRuleCall_1_1_0; }

		//right=ModMultDiv
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//ModMultDiv
		public RuleCall getRightModMultDivParserRuleCall_1_2_0() { return cRightModMultDivParserRuleCall_1_2_0; }
	}

	public class ModMultDivElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ModMultDiv");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNumericParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cModMultDivLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpModMultDivOperatorsEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightNumericParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//ModMultDiv returns Expression:
		//	Numeric ({ModMultDiv.left=current} op=ModMultDivOperators right=Numeric)*;
		public ParserRule getRule() { return rule; }

		//Numeric ({ModMultDiv.left=current} op=ModMultDivOperators right=Numeric)*
		public Group getGroup() { return cGroup; }

		//Numeric
		public RuleCall getNumericParserRuleCall_0() { return cNumericParserRuleCall_0; }

		//({ModMultDiv.left=current} op=ModMultDivOperators right=Numeric)*
		public Group getGroup_1() { return cGroup_1; }

		//{ModMultDiv.left=current}
		public Action getModMultDivLeftAction_1_0() { return cModMultDivLeftAction_1_0; }

		//op=ModMultDivOperators
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//ModMultDivOperators
		public RuleCall getOpModMultDivOperatorsEnumRuleCall_1_1_0() { return cOpModMultDivOperatorsEnumRuleCall_1_1_0; }

		//right=Numeric
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Numeric
		public RuleCall getRightNumericParserRuleCall_1_2_0() { return cRightNumericParserRuleCall_1_2_0; }
	}

	public class NumericElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Numeric");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumberLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cPlusMinusParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		////|// UnaryMinus;
		//Numeric returns Expression:
		//	NumberLiteral | "(" PlusMinus ")";
		public ParserRule getRule() { return rule; }

		//NumberLiteral | "(" PlusMinus ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//NumberLiteral
		public RuleCall getNumberLiteralParserRuleCall_0() { return cNumberLiteralParserRuleCall_0; }

		//"(" PlusMinus ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//PlusMinus
		public RuleCall getPlusMinusParserRuleCall_1_1() { return cPlusMinusParserRuleCall_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class NumberLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumberLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNumberAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cNumberPossiblySignedNumberParserRuleCall_0_0 = (RuleCall)cNumberAssignment_0.eContents().get(0);
		private final Assignment cNumericalAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final CrossReference cNumericalNumericalExCrossReference_1_0 = (CrossReference)cNumericalAssignment_1.eContents().get(0);
		private final RuleCall cNumericalNumericalExIDTerminalRuleCall_1_0_1 = (RuleCall)cNumericalNumericalExCrossReference_1_0.eContents().get(1);
		
		//NumberLiteral:
		//	number=PossiblySignedNumber | numerical=[NumericalEx];
		public ParserRule getRule() { return rule; }

		//number=PossiblySignedNumber | numerical=[NumericalEx]
		public Alternatives getAlternatives() { return cAlternatives; }

		//number=PossiblySignedNumber
		public Assignment getNumberAssignment_0() { return cNumberAssignment_0; }

		//PossiblySignedNumber
		public RuleCall getNumberPossiblySignedNumberParserRuleCall_0_0() { return cNumberPossiblySignedNumberParserRuleCall_0_0; }

		//numerical=[NumericalEx]
		public Assignment getNumericalAssignment_1() { return cNumericalAssignment_1; }

		//[NumericalEx]
		public CrossReference getNumericalNumericalExCrossReference_1_0() { return cNumericalNumericalExCrossReference_1_0; }

		//ID
		public RuleCall getNumericalNumericalExIDTerminalRuleCall_1_0_1() { return cNumericalNumericalExIDTerminalRuleCall_1_0_1; }
	}

	public class SeedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Seed");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNumberSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAssigmentSeedListAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAssigmentSeedListAseedParserRuleCall_1_0 = (RuleCall)cAssigmentSeedListAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cAssigmentSeedListAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cAssigmentSeedListAseedParserRuleCall_2_1_0 = (RuleCall)cAssigmentSeedListAssignment_2_1.eContents().get(0);
		private final Keyword cNumberSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		////UnaryMinus returns Expression:
		////'-' Numeric ({UnaryMinus.predicate=current});
		//// SEEDS
		//Seed:
		//	"#" AssigmentSeedList+=Aseed ("," AssigmentSeedList+=Aseed)* "#";
		public ParserRule getRule() { return rule; }

		//"#" AssigmentSeedList+=Aseed ("," AssigmentSeedList+=Aseed)* "#"
		public Group getGroup() { return cGroup; }

		//"#"
		public Keyword getNumberSignKeyword_0() { return cNumberSignKeyword_0; }

		//AssigmentSeedList+=Aseed
		public Assignment getAssigmentSeedListAssignment_1() { return cAssigmentSeedListAssignment_1; }

		//Aseed
		public RuleCall getAssigmentSeedListAseedParserRuleCall_1_0() { return cAssigmentSeedListAseedParserRuleCall_1_0; }

		//("," AssigmentSeedList+=Aseed)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//AssigmentSeedList+=Aseed
		public Assignment getAssigmentSeedListAssignment_2_1() { return cAssigmentSeedListAssignment_2_1; }

		//Aseed
		public RuleCall getAssigmentSeedListAseedParserRuleCall_2_1_0() { return cAssigmentSeedListAseedParserRuleCall_2_1_0; }

		//"#"
		public Keyword getNumberSignKeyword_3() { return cNumberSignKeyword_3; }
	}

	public class AseedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Aseed");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEnumSeedParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBoolAssignSeedParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cNumericalSeedParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		////A seed must hold an assigment for each parameter
		//Aseed:
		//	EnumSeed | BoolAssignSeed | NumericalSeed;
		public ParserRule getRule() { return rule; }

		//EnumSeed | BoolAssignSeed | NumericalSeed
		public Alternatives getAlternatives() { return cAlternatives; }

		//EnumSeed
		public RuleCall getEnumSeedParserRuleCall_0() { return cEnumSeedParserRuleCall_0; }

		//BoolAssignSeed
		public RuleCall getBoolAssignSeedParserRuleCall_1() { return cBoolAssignSeedParserRuleCall_1; }

		//NumericalSeed
		public RuleCall getNumericalSeedParserRuleCall_2() { return cNumericalSeedParserRuleCall_2; }
	}

	public class SeedNumberLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SeedNumberLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cNumberAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cNumberPossiblySignedNumberParserRuleCall_0_0 = (RuleCall)cNumberAssignment_0.eContents().get(0);
		private final Assignment cConstantAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final CrossReference cConstantConstantNumberCrossReference_1_0 = (CrossReference)cConstantAssignment_1.eContents().get(0);
		private final RuleCall cConstantConstantNumberIDTerminalRuleCall_1_0_1 = (RuleCall)cConstantConstantNumberCrossReference_1_0.eContents().get(1);
		
		//SeedNumberLiteral:
		//	number=PossiblySignedNumber | constant=[ConstantNumber];
		public ParserRule getRule() { return rule; }

		//number=PossiblySignedNumber | constant=[ConstantNumber]
		public Alternatives getAlternatives() { return cAlternatives; }

		//number=PossiblySignedNumber
		public Assignment getNumberAssignment_0() { return cNumberAssignment_0; }

		//PossiblySignedNumber
		public RuleCall getNumberPossiblySignedNumberParserRuleCall_0_0() { return cNumberPossiblySignedNumberParserRuleCall_0_0; }

		//constant=[ConstantNumber]
		public Assignment getConstantAssignment_1() { return cConstantAssignment_1; }

		//[ConstantNumber]
		public CrossReference getConstantConstantNumberCrossReference_1_0() { return cConstantConstantNumberCrossReference_1_0; }

		//ID
		public RuleCall getConstantConstantNumberIDTerminalRuleCall_1_0_1() { return cConstantConstantNumberIDTerminalRuleCall_1_0_1; }
	}

	public class EnumSeedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EnumSeed");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cLeftEnumerativeCrossReference_0_0 = (CrossReference)cLeftAssignment_0.eContents().get(0);
		private final RuleCall cLeftEnumerativeIDTerminalRuleCall_0_0_1 = (RuleCall)cLeftEnumerativeCrossReference_0_0.eContents().get(1);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cOpEqualsSignKeyword_1_0 = (Keyword)cOpAssignment_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cRightElementCrossReference_2_0 = (CrossReference)cRightAssignment_2.eContents().get(0);
		private final RuleCall cRightElementFQNParserRuleCall_2_0_1 = (RuleCall)cRightElementCrossReference_2_0.eContents().get(1);
		
		//EnumSeed:
		//	=> left=[Enumerative] op="=" right=[Element|FQN];
		public ParserRule getRule() { return rule; }

		//=> left=[Enumerative] op="=" right=[Element|FQN]
		public Group getGroup() { return cGroup; }

		//=> left=[Enumerative]
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }

		//[Enumerative]
		public CrossReference getLeftEnumerativeCrossReference_0_0() { return cLeftEnumerativeCrossReference_0_0; }

		//ID
		public RuleCall getLeftEnumerativeIDTerminalRuleCall_0_0_1() { return cLeftEnumerativeIDTerminalRuleCall_0_0_1; }

		//op="="
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }

		//"="
		public Keyword getOpEqualsSignKeyword_1_0() { return cOpEqualsSignKeyword_1_0; }

		//right=[Element|FQN]
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }

		//[Element|FQN]
		public CrossReference getRightElementCrossReference_2_0() { return cRightElementCrossReference_2_0; }

		//FQN
		public RuleCall getRightElementFQNParserRuleCall_2_0_1() { return cRightElementFQNParserRuleCall_2_0_1; }
	}

	public class NumericalSeedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumericalSeed");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cLeftNumericalCrossReference_0_0 = (CrossReference)cLeftAssignment_0.eContents().get(0);
		private final RuleCall cLeftNumericalIDTerminalRuleCall_0_0_1 = (RuleCall)cLeftNumericalCrossReference_0_0.eContents().get(1);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cOpEqualsSignKeyword_1_0 = (Keyword)cOpAssignment_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightSeedNumberLiteralParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//NumericalSeed:
		//	=> left=[Numerical] op="=" right=SeedNumberLiteral;
		public ParserRule getRule() { return rule; }

		//=> left=[Numerical] op="=" right=SeedNumberLiteral
		public Group getGroup() { return cGroup; }

		//=> left=[Numerical]
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }

		//[Numerical]
		public CrossReference getLeftNumericalCrossReference_0_0() { return cLeftNumericalCrossReference_0_0; }

		//ID
		public RuleCall getLeftNumericalIDTerminalRuleCall_0_0_1() { return cLeftNumericalIDTerminalRuleCall_0_0_1; }

		//op="="
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }

		//"="
		public Keyword getOpEqualsSignKeyword_1_0() { return cOpEqualsSignKeyword_1_0; }

		//right=SeedNumberLiteral
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }

		//SeedNumberLiteral
		public RuleCall getRightSeedNumberLiteralParserRuleCall_2_0() { return cRightSeedNumberLiteralParserRuleCall_2_0; }
	}

	public class BoolAssignSeedElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BoolAssignSeed");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cLeftBooleanCrossReference_0_0 = (CrossReference)cLeftAssignment_0.eContents().get(0);
		private final RuleCall cLeftBooleanIDTerminalRuleCall_0_0_1 = (RuleCall)cLeftBooleanCrossReference_0_0.eContents().get(1);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cOpEqualsSignKeyword_1_0 = (Keyword)cOpAssignment_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightBooleanConstEnumRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		////List of operators used in the expression (logic and arithmetic)
		//BoolAssignSeed:
		//	=> left=[Boolean] op="=" right=BooleanConst;
		public ParserRule getRule() { return rule; }

		//=> left=[Boolean] op="=" right=BooleanConst
		public Group getGroup() { return cGroup; }

		//=> left=[Boolean]
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }

		//[Boolean]
		public CrossReference getLeftBooleanCrossReference_0_0() { return cLeftBooleanCrossReference_0_0; }

		//ID
		public RuleCall getLeftBooleanIDTerminalRuleCall_0_0_1() { return cLeftBooleanIDTerminalRuleCall_0_0_1; }

		//op="="
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }

		//"="
		public Keyword getOpEqualsSignKeyword_1_0() { return cOpEqualsSignKeyword_1_0; }

		//right=BooleanConst
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }

		//BooleanConst
		public RuleCall getRightBooleanConstEnumRuleCall_2_0() { return cRightBooleanConstEnumRuleCall_2_0; }
	}

	public class ElementIDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "elementID");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNUMIDTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// elements can be a number followed by an ID, and integer between "" like "800"	
		//elementID returns EString:
		//	ID | NUMID;
		public ParserRule getRule() { return rule; }

		//ID | NUMID
		public Alternatives getAlternatives() { return cAlternatives; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//NUMID
		public RuleCall getNUMIDTerminalRuleCall_1() { return cNUMIDTerminalRuleCall_1; }
	}

	public class FQNElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FQN");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cElementIDParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//FQN:
		//	ID "." elementID;
		public ParserRule getRule() { return rule; }

		//ID "." elementID
		public Group getGroup() { return cGroup; }

		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }

		//elementID
		public RuleCall getElementIDParserRuleCall_2() { return cElementIDParserRuleCall_2; }
	}

	public class PossiblySignedNumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PossiblySignedNumber");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//PossiblySignedNumber returns EIntegerObject:
		//	"-"? INT;
		public ParserRule getRule() { return rule; }

		//"-"? INT
		public Group getGroup() { return cGroup; }

		//"-"?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}
	
	
	public class RelationalOperatorsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "RelationalOperators");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cGTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cGTGreaterThanSignKeyword_0_0 = (Keyword)cGTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLTEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLTLessThanSignKeyword_1_0 = (Keyword)cLTEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGEGreaterThanSignEqualsSignKeyword_2_0 = (Keyword)cGEEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cLEEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cLELessThanSignEqualsSignKeyword_3_0 = (Keyword)cLEEnumLiteralDeclaration_3.eContents().get(0);
		
		//// only comparison 
		//enum RelationalOperators returns Operators:
		//	GT=">" | LT="<" | GE=">=" | LE="<=";
		public EnumRule getRule() { return rule; }

		//GT=">" | LT="<" | GE=">=" | LE="<="
		public Alternatives getAlternatives() { return cAlternatives; }

		//GT=">"
		public EnumLiteralDeclaration getGTEnumLiteralDeclaration_0() { return cGTEnumLiteralDeclaration_0; }

		//">"
		public Keyword getGTGreaterThanSignKeyword_0_0() { return cGTGreaterThanSignKeyword_0_0; }

		//LT="<"
		public EnumLiteralDeclaration getLTEnumLiteralDeclaration_1() { return cLTEnumLiteralDeclaration_1; }

		//"<"
		public Keyword getLTLessThanSignKeyword_1_0() { return cLTLessThanSignKeyword_1_0; }

		//GE=">="
		public EnumLiteralDeclaration getGEEnumLiteralDeclaration_2() { return cGEEnumLiteralDeclaration_2; }

		//">="
		public Keyword getGEGreaterThanSignEqualsSignKeyword_2_0() { return cGEGreaterThanSignEqualsSignKeyword_2_0; }

		//LE="<="
		public EnumLiteralDeclaration getLEEnumLiteralDeclaration_3() { return cLEEnumLiteralDeclaration_3; }

		//"<="
		public Keyword getLELessThanSignEqualsSignKeyword_3_0() { return cLELessThanSignEqualsSignKeyword_3_0; }
	}

	public class AssignmentOperatorsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AssignmentOperators");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEQEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEQEqualsSignEqualsSignKeyword_0_0 = (Keyword)cEQEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNEExclamationMarkEqualsSignKeyword_1_0 = (Keyword)cNEEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum AssignmentOperators returns Operators:
		//	EQ="==" | NE="!=";
		public EnumRule getRule() { return rule; }

		//EQ="==" | NE="!="
		public Alternatives getAlternatives() { return cAlternatives; }

		//EQ="=="
		public EnumLiteralDeclaration getEQEnumLiteralDeclaration_0() { return cEQEnumLiteralDeclaration_0; }

		//"=="
		public Keyword getEQEqualsSignEqualsSignKeyword_0_0() { return cEQEqualsSignEqualsSignKeyword_0_0; }

		//NE="!="
		public EnumLiteralDeclaration getNEEnumLiteralDeclaration_1() { return cNEEnumLiteralDeclaration_1; }

		//"!="
		public Keyword getNEExclamationMarkEqualsSignKeyword_1_0() { return cNEExclamationMarkEqualsSignKeyword_1_0; }
	}

	public class AndOperatorsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "AndOperators");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAndEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAndAmpersandAmpersandKeyword_0_0 = (Keyword)cAndEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cAndmiEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cAndmiAndKeyword_1_0 = (Keyword)cAndmiEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cANDmaEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cANDmaANDKeyword_2_0 = (Keyword)cANDmaEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum AndOperators:
		//	and="&&" | andmi="and" | ANDma="AND";
		public EnumRule getRule() { return rule; }

		//and="&&" | andmi="and" | ANDma="AND"
		public Alternatives getAlternatives() { return cAlternatives; }

		//and="&&"
		public EnumLiteralDeclaration getAndEnumLiteralDeclaration_0() { return cAndEnumLiteralDeclaration_0; }

		//"&&"
		public Keyword getAndAmpersandAmpersandKeyword_0_0() { return cAndAmpersandAmpersandKeyword_0_0; }

		//andmi="and"
		public EnumLiteralDeclaration getAndmiEnumLiteralDeclaration_1() { return cAndmiEnumLiteralDeclaration_1; }

		//"and"
		public Keyword getAndmiAndKeyword_1_0() { return cAndmiAndKeyword_1_0; }

		//ANDma="AND"
		public EnumLiteralDeclaration getANDmaEnumLiteralDeclaration_2() { return cANDmaEnumLiteralDeclaration_2; }

		//"AND"
		public Keyword getANDmaANDKeyword_2_0() { return cANDmaANDKeyword_2_0; }
	}

	public class OrOperatorsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "OrOperators");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cOrEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cOrVerticalLineVerticalLineKeyword_0_0 = (Keyword)cOrEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOrmiEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cOrmiOrKeyword_1_0 = (Keyword)cOrmiEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cORmaEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cORmaORKeyword_2_0 = (Keyword)cORmaEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum OrOperators:
		//	or="||" | ormi="or" | ORma="OR";
		public EnumRule getRule() { return rule; }

		//or="||" | ormi="or" | ORma="OR"
		public Alternatives getAlternatives() { return cAlternatives; }

		//or="||"
		public EnumLiteralDeclaration getOrEnumLiteralDeclaration_0() { return cOrEnumLiteralDeclaration_0; }

		//"||"
		public Keyword getOrVerticalLineVerticalLineKeyword_0_0() { return cOrVerticalLineVerticalLineKeyword_0_0; }

		//ormi="or"
		public EnumLiteralDeclaration getOrmiEnumLiteralDeclaration_1() { return cOrmiEnumLiteralDeclaration_1; }

		//"or"
		public Keyword getOrmiOrKeyword_1_0() { return cOrmiOrKeyword_1_0; }

		//ORma="OR"
		public EnumLiteralDeclaration getORmaEnumLiteralDeclaration_2() { return cORmaEnumLiteralDeclaration_2; }

		//"OR"
		public Keyword getORmaORKeyword_2_0() { return cORmaORKeyword_2_0; }
	}

	public class PlusMinusOperatorsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "PlusMinusOperators");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPlusEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPlusPlusSignKeyword_0_0 = (Keyword)cPlusEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMinusEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMinusHyphenMinusKeyword_1_0 = (Keyword)cMinusEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum PlusMinusOperators:
		//	Plus="+" | Minus="-";
		public EnumRule getRule() { return rule; }

		//Plus="+" | Minus="-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//Plus="+"
		public EnumLiteralDeclaration getPlusEnumLiteralDeclaration_0() { return cPlusEnumLiteralDeclaration_0; }

		//"+"
		public Keyword getPlusPlusSignKeyword_0_0() { return cPlusPlusSignKeyword_0_0; }

		//Minus="-"
		public EnumLiteralDeclaration getMinusEnumLiteralDeclaration_1() { return cMinusEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getMinusHyphenMinusKeyword_1_0() { return cMinusHyphenMinusKeyword_1_0; }
	}

	public class ModMultDivOperatorsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ModMultDivOperators");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cModEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cModPercentSignKeyword_0_0 = (Keyword)cModEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMultEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMultAsteriskKeyword_1_0 = (Keyword)cMultEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDivEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDivSolidusKeyword_2_0 = (Keyword)cDivEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum ModMultDivOperators:
		//	Mod="%" | Mult="*" | Div="/";
		public EnumRule getRule() { return rule; }

		//Mod="%" | Mult="*" | Div="/"
		public Alternatives getAlternatives() { return cAlternatives; }

		//Mod="%"
		public EnumLiteralDeclaration getModEnumLiteralDeclaration_0() { return cModEnumLiteralDeclaration_0; }

		//"%"
		public Keyword getModPercentSignKeyword_0_0() { return cModPercentSignKeyword_0_0; }

		//Mult="*"
		public EnumLiteralDeclaration getMultEnumLiteralDeclaration_1() { return cMultEnumLiteralDeclaration_1; }

		//"*"
		public Keyword getMultAsteriskKeyword_1_0() { return cMultAsteriskKeyword_1_0; }

		//Div="/"
		public EnumLiteralDeclaration getDivEnumLiteralDeclaration_2() { return cDivEnumLiteralDeclaration_2; }

		//"/"
		public Keyword getDivSolidusKeyword_2_0() { return cDivSolidusKeyword_2_0; }
	}

	public class ImpliesOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ImpliesOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cImplEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cImplEqualsSignGreaterThanSignKeyword_0_0 = (Keyword)cImplEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cIffEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cIffLessThanSignEqualsSignGreaterThanSignKeyword_1_0 = (Keyword)cIffEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ImpliesOperator:
		//	Impl="=>" | Iff="<=>";
		public EnumRule getRule() { return rule; }

		//Impl="=>" | Iff="<=>"
		public Alternatives getAlternatives() { return cAlternatives; }

		//Impl="=>"
		public EnumLiteralDeclaration getImplEnumLiteralDeclaration_0() { return cImplEnumLiteralDeclaration_0; }

		//"=>"
		public Keyword getImplEqualsSignGreaterThanSignKeyword_0_0() { return cImplEqualsSignGreaterThanSignKeyword_0_0; }

		//Iff="<=>"
		public EnumLiteralDeclaration getIffEnumLiteralDeclaration_1() { return cIffEnumLiteralDeclaration_1; }

		//"<=>"
		public Keyword getIffLessThanSignEqualsSignGreaterThanSignKeyword_1_0() { return cIffLessThanSignEqualsSignGreaterThanSignKeyword_1_0; }
	}

	public class BooleanConstElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "BooleanConst");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cFalseEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cFalseFalseKeyword_0_0 = (Keyword)cFalseEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cTrueEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cTrueTrueKeyword_1_0 = (Keyword)cTrueEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum BooleanConst:
		//	false | true;
		public EnumRule getRule() { return rule; }

		//false | true
		public Alternatives getAlternatives() { return cAlternatives; }

		//false
		public EnumLiteralDeclaration getFalseEnumLiteralDeclaration_0() { return cFalseEnumLiteralDeclaration_0; }

		//"false"
		public Keyword getFalseFalseKeyword_0_0() { return cFalseFalseKeyword_0_0; }

		//true
		public EnumLiteralDeclaration getTrueEnumLiteralDeclaration_1() { return cTrueEnumLiteralDeclaration_1; }

		//"true"
		public Keyword getTrueTrueKeyword_1_0() { return cTrueTrueKeyword_1_0; }
	}
	
	private CitModelElements pCitModel;
	private ConstantElements pConstant;
	private ConstantNumberElements pConstantNumber;
	private ParameterElements pParameter;
	private ParametersExElements pParametersEx;
	private NumericalExElements pNumericalEx;
	private NumericalElements pNumerical;
	private EnumerativeTypeElements pEnumerativeType;
	private NamedTypeElements pNamedType;
	private AnonymousTypeElements pAnonymousType;
	private EnumerativeElements pEnumerative;
	private ElementElements pElement;
	private BooleanElements pBoolean;
	private NumbersElements pNumbers;
	private RangeElements pRange;
	private RuleElements pRule;
	private OrExpressionElements pOrExpression;
	private AndExpressionElements pAndExpression;
	private ImpliesExpressionElements pImpliesExpression;
	private PrimaryElements pPrimary;
	private NotExpressionElements pNotExpression;
	private AtomicPredicateElements pAtomicPredicate;
	private BoolAssignElements pBoolAssign;
	private EnumAssignElements pEnumAssign;
	private RelationalExpressionElements pRelationalExpression;
	private PlusMinusElements pPlusMinus;
	private ModMultDivElements pModMultDiv;
	private NumericElements pNumeric;
	private NumberLiteralElements pNumberLiteral;
	private SeedElements pSeed;
	private AseedElements pAseed;
	private SeedNumberLiteralElements pSeedNumberLiteral;
	private EnumSeedElements pEnumSeed;
	private NumericalSeedElements pNumericalSeed;
	private BoolAssignSeedElements pBoolAssignSeed;
	private RelationalOperatorsElements unknownRuleRelationalOperators;
	private AssignmentOperatorsElements unknownRuleAssignmentOperators;
	private AndOperatorsElements unknownRuleAndOperators;
	private OrOperatorsElements unknownRuleOrOperators;
	private PlusMinusOperatorsElements unknownRulePlusMinusOperators;
	private ModMultDivOperatorsElements unknownRuleModMultDivOperators;
	private ImpliesOperatorElements unknownRuleImpliesOperator;
	private BooleanConstElements unknownRuleBooleanConst;
	private ElementIDElements pElementID;
	private TerminalRule tNUMID;
	private FQNElements pFQN;
	private PossiblySignedNumberElements pPossiblySignedNumber;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public CitLGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("citlab.model.CitL".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//CitModel:
	//	{CitModel} "Model" name=ID // definition of constants
	//	("Definitions:" definitions+=Constant+ "end")? //type allow to declear a list of element and reuse them in the enumeratives that share a same domain
	//	("Types:" Types+=NamedType+ "end")? // Parameters - mandatory
	//	"Parameters:" parameters+=Parameter+ "end" // constraints
	//	("Constraints:" constraints+=Rule+ "end")? // seeds 
	//	("Seeds:" seeds+=Seed+ "end")? // test goals
	//	("TestGoals:" testGoals+=Rule+ "end")?;
	public CitModelElements getCitModelAccess() {
		return (pCitModel != null) ? pCitModel : (pCitModel = new CitModelElements());
	}
	
	public ParserRule getCitModelRule() {
		return getCitModelAccess().getRule();
	}

	//// for now only numerical constants
	//Constant:
	//	ConstantNumber;
	public ConstantElements getConstantAccess() {
		return (pConstant != null) ? pConstant : (pConstant = new ConstantElements());
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}

	//ConstantNumber:
	//	"Number" name=ID "=" value=INT ";";
	public ConstantNumberElements getConstantNumberAccess() {
		return (pConstantNumber != null) ? pConstantNumber : (pConstantNumber = new ConstantNumberElements());
	}
	
	public ParserRule getConstantNumberRule() {
		return getConstantNumberAccess().getRule();
	}

	//Parameter:
	//	Enumerative | Boolean | Numerical;
	public ParameterElements getParameterAccess() {
		return (pParameter != null) ? pParameter : (pParameter = new ParameterElements());
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}

	//// parameter U Numerical
	//ParametersEx:
	//	Parameter | NumericalEx;
	public ParametersExElements getParametersExAccess() {
		return (pParametersEx != null) ? pParametersEx : (pParametersEx = new ParametersExElements());
	}
	
	public ParserRule getParametersExRule() {
		return getParametersExAccess().getRule();
	}

	//NumericalEx:
	//	Numerical | ConstantNumber;
	public NumericalExElements getNumericalExAccess() {
		return (pNumericalEx != null) ? pNumericalEx : (pNumericalEx = new NumericalExElements());
	}
	
	public ParserRule getNumericalExRule() {
		return getNumericalExAccess().getRule();
	}

	//// numerical parameter
	//Numerical:
	//	Numbers | Range;
	public NumericalElements getNumericalAccess() {
		return (pNumerical != null) ? pNumerical : (pNumerical = new NumericalElements());
	}
	
	public ParserRule getNumericalRule() {
		return getNumericalAccess().getRule();
	}

	//EnumerativeType:
	//	NamedType | AnonymousType;
	public EnumerativeTypeElements getEnumerativeTypeAccess() {
		return (pEnumerativeType != null) ? pEnumerativeType : (pEnumerativeType = new EnumerativeTypeElements());
	}
	
	public ParserRule getEnumerativeTypeRule() {
		return getEnumerativeTypeAccess().getRule();
	}

	//NamedType:
	//	"EnumerativeType" name=ID "{" elements+=Element* "}" ";";
	public NamedTypeElements getNamedTypeAccess() {
		return (pNamedType != null) ? pNamedType : (pNamedType = new NamedTypeElements());
	}
	
	public ParserRule getNamedTypeRule() {
		return getNamedTypeAccess().getRule();
	}

	////An enumaritive can be a list of element or a reference to a NamedType
	//AnonymousType:
	//	elements+=Element+;
	public AnonymousTypeElements getAnonymousTypeAccess() {
		return (pAnonymousType != null) ? pAnonymousType : (pAnonymousType = new AnonymousTypeElements());
	}
	
	public ParserRule getAnonymousTypeRule() {
		return getAnonymousTypeAccess().getRule();
	}

	//// elements in the enumerative
	//Enumerative:
	//	"Enumerative" name=ID (":" namedType=[NamedType] | "{" atype=AnonymousType "}") ";";
	public EnumerativeElements getEnumerativeAccess() {
		return (pEnumerative != null) ? pEnumerative : (pEnumerative = new EnumerativeElements());
	}
	
	public ParserRule getEnumerativeRule() {
		return getEnumerativeAccess().getRule();
	}

	//Element:
	//	name=elementID;
	public ElementElements getElementAccess() {
		return (pElement != null) ? pElement : (pElement = new ElementElements());
	}
	
	public ParserRule getElementRule() {
		return getElementAccess().getRule();
	}

	//Boolean:
	//	"Boolean" name=ID ";";
	public BooleanElements getBooleanAccess() {
		return (pBoolean != null) ? pBoolean : (pBoolean = new BooleanElements());
	}
	
	public ParserRule getBooleanRule() {
		return getBooleanAccess().getRule();
	}

	//// list of numbers
	//Numbers:
	//	"Numbers" name=ID "{" values+=PossiblySignedNumber+ "}" ";";
	public NumbersElements getNumbersAccess() {
		return (pNumbers != null) ? pNumbers : (pNumbers = new NumbersElements());
	}
	
	public ParserRule getNumbersRule() {
		return getNumbersAccess().getRule();
	}

	////range of value of a constant
	//Range:
	//	"Range" name=ID "[" begin=PossiblySignedNumber ".." end=PossiblySignedNumber "]" ("step" step=INT)? ";";
	public RangeElements getRangeAccess() {
		return (pRange != null) ? pRange : (pRange = new RangeElements());
	}
	
	public ParserRule getRangeRule() {
		return getRangeAccess().getRule();
	}

	//// CONSTRAINTS
	//// expressions defined in top down way starting from less precedence	
	//Rule:
	//	"#" OrExpression "#";
	public RuleElements getRuleAccess() {
		return (pRule != null) ? pRule : (pRule = new RuleElements());
	}
	
	public ParserRule getRuleRule() {
		return getRuleAccess().getRule();
	}

	//OrExpression returns Expression:
	//	AndExpression => ({OrExpression.left=current} op=OrOperators right=AndExpression)*;
	public OrExpressionElements getOrExpressionAccess() {
		return (pOrExpression != null) ? pOrExpression : (pOrExpression = new OrExpressionElements());
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}

	//AndExpression returns Expression:
	//	ImpliesExpression => ({AndExpression.left=current} op=AndOperators right=ImpliesExpression)*;
	public AndExpressionElements getAndExpressionAccess() {
		return (pAndExpression != null) ? pAndExpression : (pAndExpression = new AndExpressionElements());
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}

	//// 
	//ImpliesExpression returns Expression:
	//	Primary ({ImpliesExpression.left=current} op=ImpliesOperator right=Primary)*;
	public ImpliesExpressionElements getImpliesExpressionAccess() {
		return (pImpliesExpression != null) ? pImpliesExpression : (pImpliesExpression = new ImpliesExpressionElements());
	}
	
	public ParserRule getImpliesExpressionRule() {
		return getImpliesExpressionAccess().getRule();
	}

	//Primary returns Expression:
	//	NotExpression | "(" OrExpression ")" | AtomicPredicate;
	public PrimaryElements getPrimaryAccess() {
		return (pPrimary != null) ? pPrimary : (pPrimary = new PrimaryElements());
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}

	//NotExpression returns Expression:
	//	("!" | "not") Primary {NotExpression.predicate=current};
	public NotExpressionElements getNotExpressionAccess() {
		return (pNotExpression != null) ? pNotExpression : (pNotExpression = new NotExpressionElements());
	}
	
	public ParserRule getNotExpressionRule() {
		return getNotExpressionAccess().getRule();
	}

	//// return an atomic predicate that cannot be further decomposed in predicates
	//AtomicPredicate:
	//	EnumAssign | BoolAssign | RelationalExpression;
	public AtomicPredicateElements getAtomicPredicateAccess() {
		return (pAtomicPredicate != null) ? pAtomicPredicate : (pAtomicPredicate = new AtomicPredicateElements());
	}
	
	public ParserRule getAtomicPredicateRule() {
		return getAtomicPredicateAccess().getRule();
	}

	//BoolAssign:
	//	=> left=[Boolean] op=AssignmentOperators right=BooleanConst;
	public BoolAssignElements getBoolAssignAccess() {
		return (pBoolAssign != null) ? pBoolAssign : (pBoolAssign = new BoolAssignElements());
	}
	
	public ParserRule getBoolAssignRule() {
		return getBoolAssignAccess().getRule();
	}

	//EnumAssign:
	//	=> left=[Enumerative] op=AssignmentOperators right=[Element|FQN];
	public EnumAssignElements getEnumAssignAccess() {
		return (pEnumAssign != null) ? pEnumAssign : (pEnumAssign = new EnumAssignElements());
	}
	
	public ParserRule getEnumAssignRule() {
		return getEnumAssignAccess().getRule();
	}

	//// numerical expressions
	//RelationalExpression:
	//	=> (left=[Numerical] op=(AssignmentOperators | RelationalOperators) right=PlusMinus);
	public RelationalExpressionElements getRelationalExpressionAccess() {
		return (pRelationalExpression != null) ? pRelationalExpression : (pRelationalExpression = new RelationalExpressionElements());
	}
	
	public ParserRule getRelationalExpressionRule() {
		return getRelationalExpressionAccess().getRule();
	}

	//PlusMinus returns Expression:
	//	ModMultDiv ({PlusMinus.left=current} op=PlusMinusOperators right=ModMultDiv)*;
	public PlusMinusElements getPlusMinusAccess() {
		return (pPlusMinus != null) ? pPlusMinus : (pPlusMinus = new PlusMinusElements());
	}
	
	public ParserRule getPlusMinusRule() {
		return getPlusMinusAccess().getRule();
	}

	//ModMultDiv returns Expression:
	//	Numeric ({ModMultDiv.left=current} op=ModMultDivOperators right=Numeric)*;
	public ModMultDivElements getModMultDivAccess() {
		return (pModMultDiv != null) ? pModMultDiv : (pModMultDiv = new ModMultDivElements());
	}
	
	public ParserRule getModMultDivRule() {
		return getModMultDivAccess().getRule();
	}

	////|// UnaryMinus;
	//Numeric returns Expression:
	//	NumberLiteral | "(" PlusMinus ")";
	public NumericElements getNumericAccess() {
		return (pNumeric != null) ? pNumeric : (pNumeric = new NumericElements());
	}
	
	public ParserRule getNumericRule() {
		return getNumericAccess().getRule();
	}

	//NumberLiteral:
	//	number=PossiblySignedNumber | numerical=[NumericalEx];
	public NumberLiteralElements getNumberLiteralAccess() {
		return (pNumberLiteral != null) ? pNumberLiteral : (pNumberLiteral = new NumberLiteralElements());
	}
	
	public ParserRule getNumberLiteralRule() {
		return getNumberLiteralAccess().getRule();
	}

	////UnaryMinus returns Expression:
	////'-' Numeric ({UnaryMinus.predicate=current});
	//// SEEDS
	//Seed:
	//	"#" AssigmentSeedList+=Aseed ("," AssigmentSeedList+=Aseed)* "#";
	public SeedElements getSeedAccess() {
		return (pSeed != null) ? pSeed : (pSeed = new SeedElements());
	}
	
	public ParserRule getSeedRule() {
		return getSeedAccess().getRule();
	}

	////A seed must hold an assigment for each parameter
	//Aseed:
	//	EnumSeed | BoolAssignSeed | NumericalSeed;
	public AseedElements getAseedAccess() {
		return (pAseed != null) ? pAseed : (pAseed = new AseedElements());
	}
	
	public ParserRule getAseedRule() {
		return getAseedAccess().getRule();
	}

	//SeedNumberLiteral:
	//	number=PossiblySignedNumber | constant=[ConstantNumber];
	public SeedNumberLiteralElements getSeedNumberLiteralAccess() {
		return (pSeedNumberLiteral != null) ? pSeedNumberLiteral : (pSeedNumberLiteral = new SeedNumberLiteralElements());
	}
	
	public ParserRule getSeedNumberLiteralRule() {
		return getSeedNumberLiteralAccess().getRule();
	}

	//EnumSeed:
	//	=> left=[Enumerative] op="=" right=[Element|FQN];
	public EnumSeedElements getEnumSeedAccess() {
		return (pEnumSeed != null) ? pEnumSeed : (pEnumSeed = new EnumSeedElements());
	}
	
	public ParserRule getEnumSeedRule() {
		return getEnumSeedAccess().getRule();
	}

	//NumericalSeed:
	//	=> left=[Numerical] op="=" right=SeedNumberLiteral;
	public NumericalSeedElements getNumericalSeedAccess() {
		return (pNumericalSeed != null) ? pNumericalSeed : (pNumericalSeed = new NumericalSeedElements());
	}
	
	public ParserRule getNumericalSeedRule() {
		return getNumericalSeedAccess().getRule();
	}

	////List of operators used in the expression (logic and arithmetic)
	//BoolAssignSeed:
	//	=> left=[Boolean] op="=" right=BooleanConst;
	public BoolAssignSeedElements getBoolAssignSeedAccess() {
		return (pBoolAssignSeed != null) ? pBoolAssignSeed : (pBoolAssignSeed = new BoolAssignSeedElements());
	}
	
	public ParserRule getBoolAssignSeedRule() {
		return getBoolAssignSeedAccess().getRule();
	}

	//// only comparison 
	//enum RelationalOperators returns Operators:
	//	GT=">" | LT="<" | GE=">=" | LE="<=";
	public RelationalOperatorsElements getRelationalOperatorsAccess() {
		return (unknownRuleRelationalOperators != null) ? unknownRuleRelationalOperators : (unknownRuleRelationalOperators = new RelationalOperatorsElements());
	}
	
	public EnumRule getRelationalOperatorsRule() {
		return getRelationalOperatorsAccess().getRule();
	}

	//enum AssignmentOperators returns Operators:
	//	EQ="==" | NE="!=";
	public AssignmentOperatorsElements getAssignmentOperatorsAccess() {
		return (unknownRuleAssignmentOperators != null) ? unknownRuleAssignmentOperators : (unknownRuleAssignmentOperators = new AssignmentOperatorsElements());
	}
	
	public EnumRule getAssignmentOperatorsRule() {
		return getAssignmentOperatorsAccess().getRule();
	}

	//enum AndOperators:
	//	and="&&" | andmi="and" | ANDma="AND";
	public AndOperatorsElements getAndOperatorsAccess() {
		return (unknownRuleAndOperators != null) ? unknownRuleAndOperators : (unknownRuleAndOperators = new AndOperatorsElements());
	}
	
	public EnumRule getAndOperatorsRule() {
		return getAndOperatorsAccess().getRule();
	}

	//enum OrOperators:
	//	or="||" | ormi="or" | ORma="OR";
	public OrOperatorsElements getOrOperatorsAccess() {
		return (unknownRuleOrOperators != null) ? unknownRuleOrOperators : (unknownRuleOrOperators = new OrOperatorsElements());
	}
	
	public EnumRule getOrOperatorsRule() {
		return getOrOperatorsAccess().getRule();
	}

	//enum PlusMinusOperators:
	//	Plus="+" | Minus="-";
	public PlusMinusOperatorsElements getPlusMinusOperatorsAccess() {
		return (unknownRulePlusMinusOperators != null) ? unknownRulePlusMinusOperators : (unknownRulePlusMinusOperators = new PlusMinusOperatorsElements());
	}
	
	public EnumRule getPlusMinusOperatorsRule() {
		return getPlusMinusOperatorsAccess().getRule();
	}

	//enum ModMultDivOperators:
	//	Mod="%" | Mult="*" | Div="/";
	public ModMultDivOperatorsElements getModMultDivOperatorsAccess() {
		return (unknownRuleModMultDivOperators != null) ? unknownRuleModMultDivOperators : (unknownRuleModMultDivOperators = new ModMultDivOperatorsElements());
	}
	
	public EnumRule getModMultDivOperatorsRule() {
		return getModMultDivOperatorsAccess().getRule();
	}

	//enum ImpliesOperator:
	//	Impl="=>" | Iff="<=>";
	public ImpliesOperatorElements getImpliesOperatorAccess() {
		return (unknownRuleImpliesOperator != null) ? unknownRuleImpliesOperator : (unknownRuleImpliesOperator = new ImpliesOperatorElements());
	}
	
	public EnumRule getImpliesOperatorRule() {
		return getImpliesOperatorAccess().getRule();
	}

	//enum BooleanConst:
	//	false | true;
	public BooleanConstElements getBooleanConstAccess() {
		return (unknownRuleBooleanConst != null) ? unknownRuleBooleanConst : (unknownRuleBooleanConst = new BooleanConstElements());
	}
	
	public EnumRule getBooleanConstRule() {
		return getBooleanConstAccess().getRule();
	}

	//// elements can be a number followed by an ID, and integer between "" like "800"	
	//elementID returns EString:
	//	ID | NUMID;
	public ElementIDElements getElementIDAccess() {
		return (pElementID != null) ? pElementID : (pElementID = new ElementIDElements());
	}
	
	public ParserRule getElementIDRule() {
		return getElementIDAccess().getRule();
	}

	//terminal NUMID:
	//	"0".."9"+ ID | "\"" INT "\"";
	public TerminalRule getNUMIDRule() {
		return (tNUMID != null) ? tNUMID : (tNUMID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NUMID"));
	} 

	//FQN:
	//	ID "." elementID;
	public FQNElements getFQNAccess() {
		return (pFQN != null) ? pFQN : (pFQN = new FQNElements());
	}
	
	public ParserRule getFQNRule() {
		return getFQNAccess().getRule();
	}

	//PossiblySignedNumber returns EIntegerObject:
	//	"-"? INT;
	public PossiblySignedNumberElements getPossiblySignedNumberAccess() {
		return (pPossiblySignedNumber != null) ? pPossiblySignedNumber : (pPossiblySignedNumber = new PossiblySignedNumberElements());
	}
	
	public ParserRule getPossiblySignedNumberRule() {
		return getPossiblySignedNumberAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
