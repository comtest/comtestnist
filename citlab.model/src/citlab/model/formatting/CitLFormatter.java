/*******************************************************************************
 * Copyright (c) 2013 University of Bergamo - Italy
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *   Paolo Vavassori - initial API and implementation
 *   Angelo Gargantini - utils and architecture
 ******************************************************************************/
/*
 * generated by Xtext
 */
package citlab.model.formatting;

import java.util.Stack;

import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter;
import org.eclipse.xtext.formatting.impl.FormattingConfig;

import citlab.model.services.CitLGrammarAccess;

/**
 * This class contains custom formatting description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#formatting
 * on how and when to use it
 * 
 * Also see {@link org.eclipse.xtext.xtext.XtextFormattingTokenSerializer} as an
 * example
 */
public class CitLFormatter extends AbstractDeclarativeFormatter {

	private static final boolean NEWLINE_AFTER_ENUM_ELEMENT = false;

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.eclipse.xtext.formatting.impl.AbstractDeclarativeFormatter#
	 * configureFormatting(org.eclipse.xtext.formatting.impl.FormattingConfig)
	 */
	@Override
	protected void configureFormatting(FormattingConfig c) {
		CitLGrammarAccess f = (CitLGrammarAccess) getGrammarAccess();
		Iterable<Keyword> keywords = GrammarUtil.containedKeywords(f
				.getGrammar());
		int counter = 0;
		Stack<Keyword> openBlockStack = new Stack<Keyword>();
		for (Keyword currentKeyword : keywords) {
			// autolinewrap must not insert a line wrap after the begin tag of a
			// rule
			if (("[".equals(currentKeyword.getValue()))
					| ("(".equals(currentKeyword.getValue()))) {
				c.setNoLinewrap().after(currentKeyword);

			}
			// autolinewrap must not insert a line wrap before the end tag of a
			// rule
			if (("]".equals(currentKeyword.getValue()))
					| (")".equals(currentKeyword.getValue()))) {
				c.setNoLinewrap().before(currentKeyword);
			}
			if ((")".equals(currentKeyword.getValue()))) {
				c.setNoLinewrap().after(currentKeyword);
			}

			if ("#".equals(currentKeyword.getValue())) {
				counter++;
				if (counter % 2 == 0)
					c.setLinewrap(1).after(currentKeyword);
			}
			if ((";".equals(currentKeyword.getValue()))
					|| (")".equals(currentKeyword.getValue()))) {
				c.setNoSpace().before(currentKeyword);
			}
			// indentation blocks begin words
			// if it is closed by end and terminates with ":" (CitModel exaluded)
			//like Types: and so on 
			if ( ! grammar.findKeywordPairs(currentKeyword.getValue(), "end").isEmpty()  && currentKeyword.getValue().endsWith(":")) {
				openBlockStack.add(currentKeyword);
				c.setLinewrap(1).after(currentKeyword);
				// indentation blocks end words
			}
			if ("end".equals(currentKeyword.getValue())) {
				c.setLinewrap(1).around(currentKeyword);
				if (!openBlockStack.isEmpty()) {
					c.setIndentation(openBlockStack.pop(), currentKeyword);

				}
			}
		}
		// set a line after the declaration of a paramter
		c.setLinewrap().after(f.getParameterRule());
		// and after Enumerative type declaration 
		c.setLinewrap().after(f.getNamedTypeRule());
		
		c.setNoSpace().around(f.getAssignmentOperatorsRule());
		c.setNoSpace().around(f.getRelationalOperatorsRule());
		c.setNoSpace().around(f.getBoolAssignAccess().getOpAssignment_1());
		c.setNoSpace().around(f.getBoolAssignSeedAccess().getOpAssignment_1());
		c.setNoSpace().around(f.getEnumSeedAccess().getOpAssignment_1());
		c.setNoSpace().around(f.getNumericalSeedAccess().getOpAssignment_1());
		c.setNoSpace().around(f.getModMultDivOperatorsRule());
		c.setNoSpace().around(f.getPlusMinusOperatorsRule());

		c.setNoLinewrap().around(f.getAssignmentOperatorsRule());
		c.setNoLinewrap().around(f.getRelationalOperatorsRule());
		c.setNoLinewrap().around(f.getBoolAssignAccess().getOpAssignment_1());
		c.setNoLinewrap().around(f.getBoolAssignSeedAccess().getOpAssignment_1());
		c.setNoLinewrap().around(f.getEnumSeedAccess().getOpAssignment_1());
		c.setNoLinewrap().around(f.getNumericalSeedAccess().getOpAssignment_1());
		c.setNoLinewrap().around(f.getModMultDivOperatorsRule());
		c.setNoLinewrap().around(f.getPlusMinusOperatorsRule());
		

		if (NEWLINE_AFTER_ENUM_ELEMENT)
			c.setLinewrap(1).after(f.getElementAccess().getNameAssignment());
		else 
			c.setNoLinewrap().after(f.getElementAccess().getNameAssignment());
		c.setLinewrap(2).after(f.getCitModelAccess().getNameIDTerminalRuleCall_2_0());
		c.setLinewrap(0, 1, 2).before(f.getSL_COMMENTRule());
		c.setLinewrap(0, 1, 2).before(f.getML_COMMENTRule());
		c.setLinewrap(0, 1, 1).after(f.getML_COMMENTRule());

	}
}
