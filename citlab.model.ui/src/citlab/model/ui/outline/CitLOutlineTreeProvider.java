/*******************************************************************************
 * Copyright (c) 2013 University of Bergamo - Italy
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *   Paolo Vavassori - initial API and implementation
 *   Angelo Gargantini - utils and architecture
 ******************************************************************************/
/*
 * generated by Xtext
 */
package citlab.model.ui.outline;

import org.eclipse.jface.viewers.StyledString;
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
import org.eclipse.xtext.ui.editor.utils.TextStyle;
import org.eclipse.xtext.ui.label.StylerFactory;

import citlab.model.citL.Aseed;
import citlab.model.citL.ConstantNumber;
import citlab.model.citL.Enumerative;
import citlab.model.citL.CitModel;
import citlab.model.citL.Numbers;
import citlab.model.citL.Range;
import citlab.model.citL.Rule;
import citlab.model.citL.Seed;

import com.google.inject.Inject;

/**
 * customization of the default outline structure
 * 
 */
public class CitLOutlineTreeProvider extends DefaultOutlineTreeProvider {

	private static final String CONSTRAINT_OUTLINE = "Constraint";
	private static final String TESTGOAL_OUTLINE = "TestGoal";
	/** The styler factory. */
	@Inject
	private StylerFactory stylerFactory;

	/**
	 * It returns the label "CitModel root" for the root of the outline tree
	 * 
	 * @param entity
	 *            the entity
	 * @return the object
	 */
	public Object _text(CitModel entity) {

		return new StyledString("CitModel: " + entity.getName(),
				stylerFactory.createXtextStyleAdapterStyler(getTypeTextStyle()));

	}

	/**
	 * Because, in the grammar of the model, seed instances have no name this
	 * method return an incremental name
	 * 
	 * @param entity
	 *            the entity
	 * @return the object
	 */
	public Object _text(Seed entity) {

		return new StyledString(
				"Seed "
						+ (((CitModel) entity.eContainer()).getSeeds().indexOf(
								entity) + 1),
				stylerFactory.createXtextStyleAdapterStyler(getTypeTextStyle()));

	}

	public Object _text(Enumerative entity) {
		if (entity.getNamedType() != null)
			return new StyledString(entity.getName() + " ::"
					+ entity.getNamedType().getName(),
					stylerFactory
							.createXtextStyleAdapterStyler(getTypeTextStyle()));
		else
			return new StyledString(entity.getName(),
					stylerFactory
							.createXtextStyleAdapterStyler(getTypeTextStyle()));

	}
	public Object _text(Numbers entity) {
		String append =new String(" { ");
		for (int n  : entity.getValues()){

			append+=(String.valueOf(n)+" ");
			
			
		}
			return new StyledString(entity.getName() +
					 append +"}",
					stylerFactory
							.createXtextStyleAdapterStyler(getTypeTextStyle()));
		

	} 
	public Object _text(Range entity) {
		
			return new StyledString(entity.getName() +"  ["+
					 entity.getBegin()+"..."+ entity.getEnd()+"]",
					stylerFactory
							.createXtextStyleAdapterStyler(getTypeTextStyle()));
		

	}
	public Object _text(ConstantNumber entity) {
		
		return new StyledString(entity.getName() +"  ["+
				 entity.getValue()+"]",
				stylerFactory
						.createXtextStyleAdapterStyler(getTypeTextStyle()));
	

}

	/**
	 * Because, in the grammar of the model, rule instances have no name this
	 * method return an incremental name
	 * 
	 * @param entity
	 *            the entity
	 * @return the object
	 */
	public Object _text(Rule rule) {
		// check if it is a constraint or a seed
		CitModel citModel = (CitModel) rule.eContainer();
		// distinguish bewteen test goal and constraint
		if (citModel.getConstraints().contains(rule)) {
			return new StyledString(CONSTRAINT_OUTLINE + " "
					+ (citModel.getConstraints().indexOf(rule) + 1),
					stylerFactory
							.createXtextStyleAdapterStyler(getTypeTextStyle()));
		} else {
			assert (citModel.getTestGoals().contains(rule));
			return new StyledString(TESTGOAL_OUTLINE + " "
					+ (citModel.getTestGoals().indexOf(rule) + 1),
					stylerFactory
							.createXtextStyleAdapterStyler(getTypeTextStyle()));
		}

	}

	/**
	 * Because, in the grammar of the model, aseed instances have no name this
	 * method return an incremental name
	 * 
	 * @param entity
	 *            the entity
	 * @return the object
	 */
	public Object _text(Aseed entity) {
		return new StyledString("Assignment "
				+ (((Seed) entity.eContainer()).getAssigmentSeedList().indexOf(
						entity) + 1),
				stylerFactory.createXtextStyleAdapterStyler(getTypeTextStyle()));

	}

	/**
	 * Gets the type text style.
	 * 
	 * @return the type text style
	 */
	protected TextStyle getTypeTextStyle() {
		TextStyle textStyle = new TextStyle();
		return textStyle;
	}

	/**
	 * This workaround resolves an xtext 2.0 bug in the outline logic rule
	 * recursion. This method set Rule entity to be a leaf stopping any king of
	 * recursive branching
	 * 
	 * @param modelElement
	 *            the model element
	 * @return true, if successful
	 */
	protected boolean _isLeaf(Rule modelElement) {

		return true;
	}

}
